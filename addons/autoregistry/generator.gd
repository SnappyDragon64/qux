@tool
extends RefCounted


const REGISTRY_CONFIGS = [
	{
		"name": "Core",
		"root_path": "res://data/registry/core/",
		"autogen_path": "res://core/registry/"
	},
	{
		"name": "Game",
		"root_path": "res://data/registry/game/",
		"autogen_path": "res://game/registry/"
	}
]

const REGISTRY_HEADER = """# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the '%s' registry (%s).

"""


func generate():
	for config in REGISTRY_CONFIGS:
		print("AutoRegistry: Processing registry config: %s" % config.name)
		_cleanup_autogen_dir(config.autogen_path)
		
		DirAccess.make_dir_absolute(config.autogen_path)

		var root_dir := DirAccess.open(config.root_path)
		
		if not root_dir:
			printerr("AutoRegistry: Registry root path not found for %s: %s" % [config.name, config.root_path])
			continue

		for subfolder_name in root_dir.get_directories():
			var registry_class_name = subfolder_name.to_pascal_case()
			_generate_registry_class(registry_class_name, subfolder_name, config)


func _cleanup_autogen_dir(autogen_path: String):
	var dir := DirAccess.open(autogen_path)
	
	if not dir:
		return

	dir.list_dir_begin()
	var file_name = dir.get_next()
	
	while file_name != "":
		if not (file_name == "." or file_name == ".."):
			dir.remove(autogen_path.path_join(file_name))
		file_name = dir.get_next()
	
	dir.list_dir_end()


func _generate_registry_class(registry_class_name: String, registry_folder: String, config: Dictionary):
	var file_path = config.autogen_path.path_join(registry_folder.to_snake_case() + ".gd")

	var content = REGISTRY_HEADER % [registry_class_name, config.name]
	content += "class_name %s\n\n" % registry_class_name

	var consts: Array[String] = []
	var full_registry_path: String = config.root_path.path_join(registry_folder)
	var dir = DirAccess.open(full_registry_path)
	
	if not dir:
		return

	var files = dir.get_files()
	
	if files.is_empty():
		FileAccess.open(file_path, FileAccess.WRITE).store_string(content)
		return

	var return_type := "Resource"
	var inferred_from_first_valid_file = false
	
	for file_name in files:
		if file_name.ends_with(".tres") or file_name.ends_with(".res"):
			return_type = _infer_type_from_tres_file(full_registry_path.path_join(file_name))
			inferred_from_first_valid_file = true
			break
	
	if not inferred_from_first_valid_file and not files.is_empty():
		push_warning("AutoRegistry: No .tres or .res files found in '%s' to infer type for registry '%s'. Defaulting to 'Resource'." % [full_registry_path, registry_class_name])
		var file = FileAccess.open(file_path, FileAccess.WRITE)
		if file:
			file.store_string(content)
		return

	for file_name in files:
		if not (file_name.ends_with(".tres") or file_name.ends_with(".res")):
			continue
		
		var id := file_name.get_basename()
		var const_name := id.to_upper()
		var resource_path := full_registry_path.path_join(file_name)

		content += "const %s: %s = preload(\"%s\")\n" % [const_name, return_type, resource_path]
		consts.append(const_name)
	
	if not consts.is_empty():
		content += "\nstatic var ALL: Array[%s] = [%s]\n" % [return_type, (", ".join(consts))]
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"
	else:
		content += "\nstatic var ALL: Array[%s] = []\n" % return_type
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"

	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(content)


func _infer_type_from_tres_file(file_path: String) -> String:
	var file := FileAccess.open(file_path, FileAccess.READ)
	
	if not file:
		push_warning("AutoRegistry: Could not open file to infer type: " + file_path)
		return "Resource"

	var first_line := file.get_line()
	
	if first_line == null or first_line.is_empty():
		var content_sample = file.get_as_text(true)
		file.seek(0)
		
		var regex_gd_resource = RegEx.new()
		regex_gd_resource.compile("\\[gd_resource.*?type=\"([^\"]+)\"")
		var result_gd_resource = regex_gd_resource.search(content_sample)
		
		if result_gd_resource:
			return result_gd_resource.get_string(1)
		
		push_warning("AutoRegistry: File is empty or first line unreadable for type inference: " + file_path)
		return "Resource"

	var regex := RegEx.new()
	regex.compile('script_class\\s*=\\s*"([^"]+)"') 
	var result := regex.search(first_line)
	
	if result:
		return result.get_string(1)

	push_warning("AutoRegistry: Could not infer type from file: " + file_path)
	return "Resource"
