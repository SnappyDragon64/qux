@tool
extends RefCounted


const REGISTRY_CONFIGS = [
	{
		"name": "Core",
		"root_path": "res://data/core/",
		"autogen_path": "res://core/registry/"
	},
	{
		"name": "Game",
		"root_path": "res://data/game/",
		"autogen_path": "res://game/registry/"
	}
]

const REGISTRY_HEADER = """# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the '%s' registry (%s).

"""


func generate():
	for config in REGISTRY_CONFIGS:
		print("AutoRegistry: Processing registry config: %s" % config.name)
		_cleanup_autogen_dir(config.autogen_path)
		
		DirAccess.make_dir_absolute(config.autogen_path)

		var root_dir := DirAccess.open(config.root_path)
		
		if not root_dir:
			printerr("AutoRegistry: Registry root path not found for %s: %s" % [config.name, config.root_path])
			continue

		for subfolder_name in root_dir.get_directories():
			var registry_class_name = subfolder_name.to_pascal_case()
			_generate_registry_class(registry_class_name, subfolder_name, config)


func _cleanup_autogen_dir(autogen_path: String):
	var dir := DirAccess.open(autogen_path)
	
	if not dir:
		return

	for file_name in dir.get_files():
		dir.remove(autogen_path.path_join(file_name))


func _collect_resources_recursively(path: String, prefix: String = "") -> Array[Dictionary]:
	var collected_files: Array[Dictionary] = []
	var dir = DirAccess.open(path)
	if not dir:
		printerr("AutoRegistry: Could not open directory for recursive scan: %s" % path)
		return collected_files

	for file_name in dir.get_files():
		if file_name.ends_with(".tres") or file_name.ends_with(".res"):
			var base_name = file_name.get_basename()
			var const_name = (prefix + base_name).to_upper()
			var resource_path = path.path_join(file_name)
			collected_files.append({"const_name": const_name, "resource_path": resource_path})

	for sub_dir_name in dir.get_directories():
		var new_prefix = prefix + sub_dir_name + "_"
		var sub_dir_path = path.path_join(sub_dir_name)
		collected_files.append_array(_collect_resources_recursively(sub_dir_path, new_prefix))

	return collected_files


func _generate_registry_class(registry_class_name: String, registry_folder: String, config: Dictionary):
	var file_path = config.autogen_path.path_join(registry_folder.to_snake_case() + ".gd")

	var content = REGISTRY_HEADER % [registry_class_name, config.name]
	content += "class_name %s\n\n" % registry_class_name

	var consts: Array[String] = []
	var full_registry_path: String = config.root_path.path_join(registry_folder)

	var all_resource_info = _collect_resources_recursively(full_registry_path)
	
	if all_resource_info.is_empty():
		var file = FileAccess.open(file_path, FileAccess.WRITE)
		if file:
			file.store_string(content)
		else:
			printerr("AutoRegistry: Failed to write empty registry file: %s" % file_path)
		return

	var return_type = _infer_type_from_tres_file(all_resource_info[0].resource_path)

	for res_info in all_resource_info:
		content += "const %s: %s = preload(\"%s\")\n" % [res_info.const_name, return_type, res_info.resource_path]
		consts.append(res_info.const_name)
	
	if not consts.is_empty():
		content += "\nstatic var ALL: Array[%s] = [%s]\n" % [return_type, (", ".join(consts))]
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"
	else:
		content += "\nstatic var ALL: Array[%s] = []\n" % return_type
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"

	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(content)
	else:
		printerr("AutoRegistry: Failed to write registry file: %s" % file_path)


func _infer_type_from_tres_file(file_path: String) -> String:
	var file := FileAccess.open(file_path, FileAccess.READ)
	
	if not file:
		push_warning("AutoRegistry: Could not open file to infer type: " + file_path)
		return "Resource"

	var first_line := file.get_line()
	
	if first_line == null or first_line.is_empty():
		var content_sample = file.get_as_text(true)
		file.seek(0)
		
		var regex_gd_resource = RegEx.new()
		regex_gd_resource.compile("\\[gd_resource.*?type=\"([^\"]+)\"")
		var result_gd_resource = regex_gd_resource.search(content_sample)
		
		if result_gd_resource:
			return result_gd_resource.get_string(1)
		
		push_warning("AutoRegistry: File is empty or first line unreadable for type inference: " + file_path)
		return "Resource"

	var regex := RegEx.new()
	regex.compile('script_class\\s*=\\s*"([^"]+)"') 
	var result := regex.search(first_line)
	
	if result:
		return result.get_string(1)

	push_warning("AutoRegistry: Could not infer type from file: " + file_path)
	return "Resource"
