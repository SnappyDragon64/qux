# res://addons/autoregistry/generator.gd
@tool
extends RefCounted


const REGISTRY_ROOT_PATH = "res://data/registry/"
const AUTOGEN_PATH = "res://core/registry/"

const REGISTRY_HEADER = """# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the '%s' registry.

"""


func generate():
	_cleanup_autogen_dir()
	
	DirAccess.make_dir_absolute(AUTOGEN_PATH)

	var root_dir := DirAccess.open(REGISTRY_ROOT_PATH)
	if not root_dir:
		printerr("AutoRegistry: Registry root path not found: %s" % REGISTRY_ROOT_PATH)
		return


	for subfolder_name in root_dir.get_directories():
		var registry_class_name = subfolder_name.to_pascal_case()
		_generate_registry_class(registry_class_name, subfolder_name)


func _cleanup_autogen_dir():
	var dir := DirAccess.open(AUTOGEN_PATH)
	if not dir:
		return

	dir.list_dir_begin()
	var file_name = dir.get_next()
	while file_name != "":
		if not (file_name == "." or file_name == ".."):
			dir.remove(AUTOGEN_PATH.path_join(file_name))
		file_name = dir.get_next()
	dir.list_dir_end()


func _generate_registry_class(registry_class_name: String, registry_folder: String):
	var file_path = AUTOGEN_PATH.path_join(registry_folder.to_snake_case() + ".gd")

	var content = REGISTRY_HEADER % registry_class_name
	content += "class_name %s\n\n" % registry_class_name

	var consts: Array[String] = []
	var full_registry_path = REGISTRY_ROOT_PATH.path_join(registry_folder)
	var dir = DirAccess.open(full_registry_path)
	if not dir: return

	var files = dir.get_files()
	if files.is_empty():
		return

	var return_type := "Resource"
	for file_name in files:
		if file_name.ends_with(".tres") or file_name.ends_with(".res"):
			return_type = _infer_type_from_tres_file(full_registry_path.path_join(file_name))
			break

	for file_name in files:
		if not (file_name.ends_with(".tres") or file_name.ends_with(".res")):
			continue
		
		var id := file_name.get_basename()
		var const_name := id.to_upper()
		var resource_path := full_registry_path.path_join(file_name)
		
		content += "const %s: %s = preload(\"%s\")\n" % [const_name, return_type, resource_path]
		consts.append(const_name)
	
	content += "\nstatic var ALL: Array[%s] = [%s]\n" % [return_type, (", ".join(consts))]
	content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
	content += "    return ALL\n"

	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file:
		file.store_string(content)


func _infer_type_from_tres_file(file_path: String) -> String:
	var file := FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_warning("AutoRegistry: Could not open file to infer type: " + file_path)
		return "Resource"

	var first_line := file.get_line()
	
	var regex := RegEx.new()
	regex.compile('script_class\\s*=\\s*"([^"]+)"')
	var result := regex.search(first_line)

	if result:
		return result.get_string(1)

	regex.compile('type\\s*=\\s*"([^"]+)"')
	result = regex.search(first_line)
	if result:
		return result.get_string(1)

	return "Resource"
